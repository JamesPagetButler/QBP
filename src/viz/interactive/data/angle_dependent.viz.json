{
  "_schema": {
    "description": "QBP Proof Visualization Schema v1.0",
    "levels": {
      "L4_formal": "Lean syntax - exact code from proof files, for proof assistant users",
      "L3_math": "Mathematical notation - conventional symbols, for physicists/mathematicians",
      "L2_physical": "Physics interpretation - what it means physically, for students",
      "L1_intuitive": "Plain English - accessible explanation, for general audience"
    },
    "guidelines": "L4 should be copy-pasteable Lean. L3 uses standard math notation. L2 connects to observable phenomena. L1 uses analogies and avoids jargon.",
    "axiom_sources": {
      "QBP/Basic.lean": "Core axioms: states are unit quaternions, observables are pure quaternions, expectation via dot product",
      "QBP/Experiments/AngleDependent.lean": "Experiment-specific theorems building on Basic.lean axioms"
    }
  },
  "experiment_id": "01b_angle_dependent",
  "title": "Angle-Dependent Measurement: P(+) = cos^2(theta/2)",
  "description": "Formal proof that the QBP framework correctly predicts the probability formula P(+) = cos^2(theta/2) for measuring a state at angle theta from the measurement axis. This generalizes the Stern-Gerlach result to arbitrary angles.",
  "walk_order": [
    "isPureQuaternion",
    "isUnitQuaternion",
    "vecDot",
    "expectationValue",
    "probUp",
    "psiAngle",
    "spinZObservable",
    "psiAngle_is_pure",
    "spinZObservable_is_pure",
    "psiAngle_is_unit",
    "expectation_angle",
    "prob_up_angle",
    "prob_up_angle_cos_sq",
    "prob_down_angle_sin_sq",
    "prob_up_theta_zero",
    "prob_up_theta_pi",
    "prob_up_theta_pi_div_two",
    "angle_consistent_with_stern_gerlach"
  ],
  "nodes": {
    "isPureQuaternion": {
      "display_name": "Pure Quaternion Definition",
      "kind": "axiom",
      "source_file": "QBP/Basic.lean",
      "source_line": 13,
      "L4_formal": "def isPureQuaternion (q : Q) : Prop := q.re = 0",
      "L3_math": "A quaternion q = a + bi + cj + dk is pure iff a = 0",
      "L2_physical": "Pure quaternions represent physical directions in 3D space. They're the 'arrows' we use to describe spin orientations and measurement axes.",
      "L1_intuitive": "Picture pointing your finger in any direction - up, sideways, diagonally. That's what a pure quaternion captures: a direction in space, nothing more. No 'extra stuff' hiding in another dimension.",
      "key_insight": "Pure quaternions are directions, not scalars.",
      "depends_on": []
    },
    "isUnitQuaternion": {
      "display_name": "Unit Quaternion Definition",
      "kind": "axiom",
      "source_file": "QBP/Basic.lean",
      "source_line": 10,
      "L4_formal": "def isUnitQuaternion (q : Q) : Prop := q.normSq = 1",
      "L3_math": "|q|^2 = 1, the quaternion has unit length",
      "L2_physical": "Unit quaternions represent normalized quantum states. The unit length constraint ensures probabilities sum to 1.",
      "L1_intuitive": "Think of a compass needle - it can point any direction, but it's always the same length. A unit quaternion is like that: direction matters, but the 'strength' is always exactly 1. This keeps our probabilities sensible.",
      "key_insight": "Normalization ensures valid probabilities.",
      "depends_on": []
    },
    "vecDot": {
      "display_name": "Vector Dot Product",
      "kind": "definition",
      "source_file": "QBP/Basic.lean",
      "source_line": 36,
      "L4_formal": "def vecDot (q1 q2 : Q) : Real :=\n  q1.imI * q2.imI + q1.imJ * q2.imJ + q1.imK * q2.imK",
      "L3_math": "<a, b> = a_i*b_i + a_j*b_j + a_k*b_k (Euclidean inner product)",
      "L2_physical": "Measures how aligned two directions are. Zero means perpendicular; +1 means parallel; -1 means anti-parallel.",
      "L1_intuitive": "Hold two pencils. If they point the same way, they're 'very aligned' (+1). If they're at right angles, they're 'not aligned at all' (0). If they point opposite ways, they're 'anti-aligned' (-1). The dot product measures this.",
      "key_insight": "Alignment between state and measurement determines outcome bias.",
      "depends_on": []
    },
    "expectationValue": {
      "display_name": "Expectation Value",
      "kind": "definition",
      "source_file": "QBP/Basic.lean",
      "source_line": 44,
      "L4_formal": "def expectationValue (psi O : Q) : Real :=\n  let psi_vec := vecPart psi\n  let O_vec := vecPart O\n  vecDot psi_vec O_vec",
      "L3_math": "<O>_psi = <psi, O> = cos(theta) where theta is angle between psi and O",
      "L2_physical": "The average measurement result. If you measured many identical particles, this is what you'd get on average: +1 times P(+) plus -1 times P(-).",
      "L1_intuitive": "Imagine flipping a weighted coin many times. The expectation is your average result. For quantum spin: if the particle points at the detector, you always get +1. If it points away, always -1. At an angle? You get a mix, and the average is the cosine of that angle.",
      "key_insight": "Expectation value = cosine of angle between state and measurement.",
      "depends_on": ["vecDot"]
    },
    "probUp": {
      "display_name": "Probability Formula (Up)",
      "kind": "definition",
      "source_file": "QBP/Basic.lean",
      "source_line": 50,
      "L4_formal": "noncomputable def probUp (psi O : Q) : Real := (1 + expectationValue psi O) / 2",
      "L3_math": "P(+) = (1 + <O>)/2 = (1 + cos theta)/2",
      "L2_physical": "The Born rule for spin-1/2: converts the expectation value into a probability. This formula ensures 0 <= P <= 1.",
      "L1_intuitive": "We need to turn 'average result' (which ranges from -1 to +1) into a probability (which must be between 0% and 100%). This formula does exactly that: add 1, divide by 2. Simple arithmetic, profound physics.",
      "key_insight": "The Born rule bridges expectation values and probabilities.",
      "depends_on": ["expectationValue"]
    },
    "psiAngle": {
      "display_name": "State at Angle theta",
      "kind": "definition",
      "tags": ["angle"],
      "proof_role": "utility",
      "source_file": "QBP/Experiments/AngleDependent.lean",
      "source_line": 25,
      "L4_formal": "noncomputable def psiAngle (theta : Real) : Q := <0, Real.sin theta, 0, Real.cos theta>",
      "L3_math": "psi(theta) = sin(theta)*i + cos(theta)*k, a state in the xz-plane at angle theta from z-axis",
      "L2_physical": "A spin state tilted at angle theta from vertical. At theta=0, it points straight up (z). At theta=90 deg, it points sideways (x). At theta=180 deg, it points down (-z).",
      "L1_intuitive": "Stand up and point at the ceiling - that's theta=0. Now slowly tilt your arm toward the wall - you're increasing theta. Point straight at the wall? That's theta=90 deg. Point at the floor? That's theta=180 deg. This formula captures your arm's direction mathematically.",
      "key_insight": "We can prepare a particle pointing at any angle we want.",
      "depends_on": []
    },
    "spinZObservable": {
      "display_name": "Z-Axis Measurement",
      "kind": "definition",
      "source_file": "QBP/Experiments/AngleDependent.lean",
      "source_line": 28,
      "L4_formal": "def spinZObservable : Q := SPIN_Z  -- the quaternion k = <0, 0, 0, 1>",
      "L3_math": "O_z = k, the spin-z measurement axis (vertical)",
      "L2_physical": "A Stern-Gerlach apparatus oriented vertically. It separates particles into 'spin-up' and 'spin-down' along the z-axis.",
      "L1_intuitive": "The detector is like a bouncer at a club with one question: 'Are you pointing up or down?' It doesn't care about left/right or forward/back - just up or down. Every particle must answer one way or the other.",
      "key_insight": "We're always measuring along z, but varying the state's angle.",
      "depends_on": []
    },
    "psiAngle_is_pure": {
      "display_name": "Angle State is Pure",
      "kind": "theorem",
      "tags": ["angle"],
      "proof_role": "lemma",
      "source_file": "QBP/Experiments/AngleDependent.lean",
      "source_line": 33,
      "L4_formal": "theorem psiAngle_is_pure (theta : Real) : isPureQuaternion (psiAngle theta) := rfl",
      "L3_math": "Re(psi(theta)) = 0 for all theta",
      "L2_physical": "The angle-dependent state represents a genuine direction in 3D space - it has no scalar component regardless of the angle.",
      "L1_intuitive": "No matter how you tilt your pointing arm, it's still just pointing somewhere. It doesn't magically gain extra dimensions or become something other than a direction. Math confirms: this state is always a valid 'direction in space.'",
      "key_insight": "Valid states at all angles.",
      "depends_on": ["isPureQuaternion", "psiAngle"]
    },
    "spinZObservable_is_pure": {
      "display_name": "Z-Measurement is Pure",
      "kind": "theorem",
      "source_file": "QBP/Experiments/AngleDependent.lean",
      "source_line": 36,
      "L4_formal": "theorem spinZObservable_is_pure : isPureQuaternion spinZObservable := spin_z_is_pure",
      "L3_math": "Re(O_z) = 0",
      "L2_physical": "The z-axis measurement is a valid observable - it represents a real physical direction.",
      "L1_intuitive": "The 'up/down detector' is measuring a real direction in space - straight up. Nothing weird or abstract about it. It's as real as pointing at the ceiling.",
      "key_insight": "Valid measurement axis.",
      "depends_on": ["isPureQuaternion", "spinZObservable"]
    },
    "psiAngle_is_unit": {
      "display_name": "Angle State is Normalized",
      "kind": "theorem",
      "tags": ["angle"],
      "proof_role": "lemma",
      "source_file": "QBP/Experiments/AngleDependent.lean",
      "source_line": 39,
      "L4_formal": "theorem psiAngle_is_unit (theta : Real) : isUnitQuaternion (psiAngle theta) := by\n  unfold isUnitQuaternion psiAngle\n  simp [Quaternion.normSq]\n  ring_nf\n  exact Real.sin_sq_add_cos_sq theta",
      "L3_math": "|psi(theta)|^2 = sin^2(theta) + cos^2(theta) = 1 (Pythagorean identity)",
      "L2_physical": "The state has unit length for all angles. This is guaranteed by the fundamental trigonometric identity sin^2 + cos^2 = 1.",
      "L1_intuitive": "Remember from geometry: sin^2 + cos^2 always equals 1? That ancient identity saves us here. No matter how you tilt the state, its 'length' stays exactly 1. The math does it automatically - we didn't have to force it.",
      "key_insight": "Normalization preserved at all angles via Pythagorean identity.",
      "depends_on": ["isUnitQuaternion", "psiAngle"]
    },
    "expectation_angle": {
      "display_name": "Expectation = cos(theta)",
      "kind": "theorem",
      "tags": ["angle"],
      "proof_role": "lemma",
      "source_file": "QBP/Experiments/AngleDependent.lean",
      "source_line": 52,
      "L4_formal": "theorem expectation_angle (theta : Real) :\n    expectationValue (psiAngle theta) spinZObservable = Real.cos theta := by\n  unfold expectationValue psiAngle spinZObservable vecDot vecPart SPIN_Z\n  simp",
      "L3_math": "<O_z>_psi(theta) = cos(theta)",
      "L2_physical": "The average measurement result is simply the cosine of the angle between state and detector. This is the projection of the state onto the measurement axis.",
      "L1_intuitive": "Tilt your arm at angle theta from vertical. How much of your pointing is 'upward'? That's exactly what cosine measures - the vertical component of your tilt. At theta=0 (pointing up), cos=1. At theta=90 deg (pointing sideways), cos=0. At theta=180 deg (pointing down), cos=-1.",
      "key_insight": "Cosine encodes the projection onto the measurement axis.",
      "depends_on": ["expectationValue", "psiAngle", "spinZObservable"]
    },
    "prob_up_angle": {
      "display_name": "P(+) = (1 + cos theta)/2",
      "kind": "theorem",
      "tags": ["angle"],
      "proof_role": "lemma",
      "source_file": "QBP/Experiments/AngleDependent.lean",
      "source_line": 62,
      "L4_formal": "theorem prob_up_angle (theta : Real) :\n    probUp (psiAngle theta) spinZObservable = (1 + Real.cos theta) / 2 := by\n  unfold probUp\n  rw [expectation_angle]",
      "L3_math": "P(+|theta) = (1 + cos theta)/2",
      "L2_physical": "The probability of measuring 'spin-up' follows directly from the expectation value via the Born rule.",
      "L1_intuitive": "Take the cosine (ranges -1 to +1), add 1 (now ranges 0 to 2), divide by 2 (now ranges 0 to 1). That's your probability! Pointing up? cos=1, so P=(1+1)/2=100%. Pointing down? cos=-1, so P=(1-1)/2=0%. Sideways? cos=0, so P=1/2=50%.",
      "key_insight": "Linear transformation from cosine to probability.",
      "depends_on": ["probUp", "expectation_angle"]
    },
    "prob_up_angle_cos_sq": {
      "display_name": "P(+) = cos^2(theta/2)",
      "kind": "theorem",
      "tags": ["angle"],
      "proof_role": "goal",
      "source_file": "QBP/Experiments/AngleDependent.lean",
      "source_line": 69,
      "L4_formal": "theorem prob_up_angle_cos_sq (theta : Real) :\n    probUp (psiAngle theta) spinZObservable = Real.cos (theta / 2) ^ 2 := by\n  rw [prob_up_angle]\n  rw [Real.cos_sq]\n  ring_nf",
      "L3_math": "P(+|theta) = cos^2(theta/2), using the half-angle identity: cos^2(theta/2) = (1 + cos theta)/2",
      "L2_physical": "The famous quantum mechanical probability formula! The half-angle form reveals the deep connection to spinors - spin-1/2 particles see half the angle.",
      "L1_intuitive": "HERE'S THE BIG RESULT: probability = cosine-squared of HALF the angle. Why half? Because spin-1/2 particles are weird - they need to rotate 720 deg, not 360 deg, to get back to where they started. That 'half' is the fingerprint of their quantum nature.",
      "key_insight": "The half-angle is the signature of spin-1/2 particles.",
      "depends_on": ["prob_up_angle"]
    },
    "prob_down_angle_sin_sq": {
      "display_name": "P(-) = sin^2(theta/2)",
      "kind": "theorem",
      "tags": ["angle"],
      "proof_role": "goal",
      "source_file": "QBP/Experiments/AngleDependent.lean",
      "source_line": 84,
      "L4_formal": "theorem prob_down_angle_sin_sq (theta : Real) :\n    probDown (psiAngle theta) spinZObservable = Real.sin (theta / 2) ^ 2 := by\n  rw [prob_down_angle]\n  have h : Real.sin (theta / 2) ^ 2 = (1 - Real.cos theta) / 2 := by\n    have h1 : Real.cos theta = Real.cos (2 * (theta / 2)) := by ring_nf\n    rw [h1, Real.cos_two_mul, Real.sin_sq]\n    ring\n  rw [h]",
      "L3_math": "P(-|theta) = sin^2(theta/2) = (1 - cos theta)/2",
      "L2_physical": "The complementary probability for 'spin-down'. Note that P(+) + P(-) = cos^2(theta/2) + sin^2(theta/2) = 1, as required.",
      "L1_intuitive": "What goes up must... well, not go up. If there's a 70% chance of 'up', there's a 30% chance of 'down'. The two always add to 100%. Math guarantees it: cos^2 + sin^2 = 1. Always. Forever. No exceptions.",
      "key_insight": "Probabilities sum to 1 via Pythagorean identity.",
      "depends_on": ["prob_up_angle_cos_sq"]
    },
    "prob_up_theta_zero": {
      "display_name": "theta=0: Aligned -> P(+)=1",
      "kind": "theorem",
      "tags": ["angle"],
      "source_file": "QBP/Experiments/AngleDependent.lean",
      "source_line": 95,
      "L4_formal": "theorem prob_up_theta_zero : probUp (psiAngle 0) spinZObservable = 1 := by\n  rw [prob_up_angle]\n  simp [Real.cos_zero]",
      "L3_math": "P(+|0) = cos^2(0) = 1",
      "L2_physical": "When the state points along +z (theta=0), measuring along z always gives 'up'. No uncertainty - perfect alignment means certain outcome.",
      "L1_intuitive": "Point straight up, ask 'are you pointing up?' - obviously yes, 100% of the time. No randomness, no uncertainty. When you're perfectly aligned with what the detector is looking for, you always pass the test.",
      "key_insight": "Perfect alignment eliminates quantum randomness.",
      "depends_on": ["prob_up_angle"]
    },
    "prob_up_theta_pi": {
      "display_name": "theta=pi: Anti-aligned -> P(+)=0",
      "kind": "theorem",
      "tags": ["angle"],
      "source_file": "QBP/Experiments/AngleDependent.lean",
      "source_line": 100,
      "L4_formal": "theorem prob_up_theta_pi : probUp (psiAngle Real.pi) spinZObservable = 0 := by\n  rw [prob_up_angle]\n  simp [Real.cos_pi]",
      "L3_math": "P(+|pi) = cos^2(pi/2) = 0",
      "L2_physical": "When the state points along -z (theta=pi), measuring along z always gives 'down'. The particle is definitely pointing the opposite way.",
      "L1_intuitive": "Point straight down, ask 'are you pointing up?' - obviously no, 0% of the time. You're pointing the exact opposite direction. No chance of being mistaken for 'up.'",
      "key_insight": "Anti-alignment also eliminates randomness (certain 'down').",
      "depends_on": ["prob_up_angle"]
    },
    "prob_up_theta_pi_div_two": {
      "display_name": "theta=pi/2: Perpendicular -> P(+)=1/2",
      "kind": "theorem",
      "tags": ["angle"],
      "source_file": "QBP/Experiments/AngleDependent.lean",
      "source_line": 106,
      "L4_formal": "theorem prob_up_theta_pi_div_two :\n    probUp (psiAngle (Real.pi / 2)) spinZObservable = 1 / 2 := by\n  rw [prob_up_angle]\n  simp [Real.cos_pi_div_two]",
      "L3_math": "P(+|pi/2) = cos^2(pi/4) = 1/2",
      "L2_physical": "When the state is perpendicular to the measurement axis, we get maximum quantum randomness: exactly 50/50. This is the Stern-Gerlach case.",
      "L1_intuitive": "Point sideways, ask 'up or down?' - it's a perfect coin flip, exactly 50/50. The particle isn't hiding anything; it genuinely has no preference. This is quantum randomness in its purest form: not ignorance, but true indeterminacy.",
      "key_insight": "Perpendicular = maximum uncertainty = perfect coin flip.",
      "depends_on": ["prob_up_angle"]
    },
    "angle_consistent_with_stern_gerlach": {
      "display_name": "Matches Stern-Gerlach at theta=pi/2",
      "kind": "theorem",
      "tags": ["angle"],
      "proof_role": "goal",
      "source_file": "QBP/Experiments/AngleDependent.lean",
      "source_line": 115,
      "L4_formal": "theorem angle_consistent_with_stern_gerlach :\n    psiAngle (Real.pi / 2) = SPIN_X := by\n  unfold psiAngle SPIN_X\n  simp [Real.sin_pi_div_two, Real.cos_pi_div_two]",
      "L3_math": "psi(pi/2) = sin(pi/2)*i + cos(pi/2)*k = i = SPIN_X",
      "L2_physical": "At theta=90 deg, our angle-dependent state reduces to exactly the spin-x state from the Stern-Gerlach experiment. The formulas are consistent.",
      "L1_intuitive": "Remember Experiment 01? Particle pointing sideways (x-direction), detector asking up/down, perfect 50/50 split? Our new formula gives the exact same answer when theta=90 deg. The general formula contains the special case. Math is beautifully consistent.",
      "key_insight": "The angle formula generalizes Stern-Gerlach.",
      "depends_on": ["psiAngle", "prob_up_theta_pi_div_two"]
    }
  }
}
